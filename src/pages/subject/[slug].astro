---
export const prerender = true;
import FavoritesButton from "../../components/Misc/FavoritesButton";

import BaseLayout from '../../layouts/BaseLayout.astro'
import items from '../../data/items.json'
import { slugify } from '../../utils/slugify.js'
import SubjectInfo from '../../utils/loc.jsx'

const { slug } = Astro.params

// Helpers so we handle strings or { name, uri }
const subjectNameOf = (s) => (typeof s === 'string' ? s : s?.name || '')
const subjectUriOf  = (s) => (typeof s === 'object' ? s?.uri || null : null)

// Generate dynamic paths using slugs
export async function getStaticPaths() {
	const slugs = items.flatMap((item) =>
			(item.subjectAI || [])
			  .map((subject) => (typeof subject === 'string' ? subject : subject?.name || ''))
		   .filter(Boolean)
	 .map((name) => slugify(name))
	)
	const uniqueSlugs = Array.from(new Set(slugs))
	return uniqueSlugs.map((slug) => ({ params: { slug } }))
}

// Find items for this subject
const subjectItems = items
	.filter((item) => (item.subjectAI || [])
		.some((subject) => slugify(subjectNameOf(subject)) === slug)
	)
	.sort((a, b) => a.title.localeCompare(b.title))

if (!subjectItems.length) {
	return new Response('Not Found', { status: 404 })
}

// Canonical subject (prefer one with a URI)
const allSubjects = subjectItems.flatMap((it) => it.subjectAI || [])
const candidates  = allSubjects.filter((s) => slugify(subjectNameOf(s)) === slug)
const canonical   = candidates.find((s) => subjectUriOf(s)) || candidates[0]

const CANON       = 'https://www.kaplancollection.org'
const subjectName = subjectNameOf(canonical) || 'Unknown Subject'
const rawUri      = subjectUriOf(canonical)

// Normalize authority link (Wikidata/LOC)
let authorityHref = null
if (rawUri) {
	if (rawUri.startsWith('http')) {
		authorityHref = rawUri
	} else if (/^Q\d+$/i.test(rawUri)) {
		authorityHref = `https://www.wikidata.org/wiki/${encodeURIComponent(rawUri)}`
	} else if (/^(sh|sj|sp)\d+/.test(rawUri)) {
		authorityHref = `https://id.loc.gov/authorities/subjects/${rawUri}`
	}
}
const subjectNameFrom = (s) => (typeof s === 'string' ? s : s?.name || s?.label || '');

// Use this instead of undefined `url`
const pageUrl = `${CANON}/subject/${slug}`
const name = subjectNameFrom(allSubjects.find((s) => slugify(subjectNameFrom(s)) === slug)) || slug;

// JSON-LD

const itemUrls = subjectItems.map((it) =>
	`${CANON}/item/${encodeURIComponent(it.slug || slugify(it.title))}`
)

const extractUris = (entry) => {
	const u = typeof entry === 'object' ? entry?.uri : null
	if (!u) return []
	return Array.isArray(u) ? u.filter(Boolean) : [u]
}

// Gather from all matching candidates (you already have `candidates`)
const rawUris = Array.from(new Set(
	candidates.flatMap(extractUris)
))

// Normalize each to a full URL; support QIDs and LoC IDs mixed in
const normalized = rawUris.map((u) => {
	if (u.startsWith('http')) return u
	if (/^Q\d+$/i.test(u)) return `https://www.wikidata.org/wiki/${encodeURIComponent(u)}`
	if (/^(sh|sj|sp)\d+$/i.test(u)) return `https://id.loc.gov/authorities/subjects/${u}`
	return null
}).filter(Boolean)

// sameAs array (both WKD + LoC as needed)
const sameAs = Array.from(new Set(normalized))

// inDefinedTermSet: include LoC scheme if present (can be an array if multiple schemes)
const termSets = []
if (sameAs.some((u) => u.startsWith('https://id.loc.gov/authorities/subjects/'))) {
	termSets.push('https://id.loc.gov/authorities/subjects')
}
// If you also use other controlled vocabularies with known scheme URLs, push them here.
// e.g. termSets.push('https://www.wikidata.org')  // optional; usually not needed

// For UI: show both authority links (optional)
const authorityLinks = sameAs
	.map((u) => ({ href: u, label: u.includes('wikidata.org') ? 'Wikidata' : u.includes('id.loc.gov') ? 'LoC' : 'Authority' }))
	.sort((a, b) => a.label.localeCompare(b.label))
const websiteId   = `${CANON}#website`;
const termSetId   = `${CANON}/subject#definedTermSet`;
const definedTermId = `${CANON}/subject/${slug}#term`;
const listUrls = subjectItems.map((it) => `${CANON}/item/${encodeURIComponent(it.slug || slugify(it.title))}`);

const pageGraph = [
	{
		"@type": "DefinedTermSet",
		"@id": termSetId,
		name: "Kaplan Collection Subject Vocabulary",
		url: `${CANON}/subject`,
		isPartOf: { "@id": websiteId }
	},
	{
		"@type": "DefinedTerm",
		"@id": definedTermId,
		name,
		termCode: slug,
		url: `${CANON}/subject/${slug}`,
		inDefinedTermSet: { "@id": termSetId },
		isPartOf: { "@id": websiteId },
		...(sameAs ? { sameAs } : {})
	},
	{
		"@type": "ItemList",
		name: `Items with subject: ${name}`,
		numberOfItems: listUrls.length,
		itemListElement: listUrls.map((url, i) => ({ "@type": "ListItem", position: i + 1, url })),
		isPartOf: { "@id": websiteId }
	}
];

const description = listUrls.length
	? `Explore ${listUrls.length} item${listUrls.length===1?'':'s'} tagged with “${name}”.`
	: `No items currently tagged with “${name}”.`;

---

<BaseLayout
	title={`${name} — Subject`}
	description={description}
	ogImage={subjectItems[0]?.thumbnail}
	headGraph={pageGraph}
>
	<Fragment slot="headContent" />


	<section class="py-8 bg-white md:py-16 dark:bg-gray-900 antialiased">
	<div class="max-w-screen-xl px-4 mx-auto 2xl:px-0">
	<h1 class="text-2xl font-semibold text-gray-900 sm:text-3xl dark:text-white">
	Subject: {subjectName}
	</h1>

	{authorityHref?.startsWith('https://id.loc.gov/authorities/subjects/')
		? (
		<SubjectInfo client:only="react" subjectUri={`${authorityHref}.json`} />
		)
		: authorityHref
		? (
		<p class="text-gray-600 dark:text-gray-300 mt-2">
			Additional details available at the{' '}
		<a href={authorityHref} target="_blank" rel="noopener noreferrer" class="text-blue-700 hover:underline dark:text-blue-400">
		authority record ↗
		</a>.
		</p>
		)
		: (
		<p class="text-gray-600 dark:text-gray-300 mt-2">
		No additional authority information available for {subjectName}.
	</p>
	)
	}

	<hr class="my-6 border-gray-200 dark:border-gray-800" />

	<div class="grid grid-cols-1 sm:grid-cols-4 lg:grid-cols-6 gap-6 mt-6">
	{subjectItems.map((item) => {
		const s = item.slug || slugify(item.title)
		return (
			<article key={s} class="p-4 border border-gray-200 rounded-lg shadow hover:shadow-lg transition dark:border-gray-800">
			<a href={`/item/${s}`} class="block">
		{item.thumbnail ? (
				<img
				src={item.thumbnail}
			alt={item.title}
			class="w-full h-48 object-contain rounded-lg mb-4"
			loading="lazy"
			decoding="async"
			/>
		) : (
		<div class="w-full h-48 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-center text-gray-500">
		No Image
		</div>
		)}
		</a>

		<a href={`/item/${s}`} class="block text-blue-600 hover:underline text-lg font-semibold dark:text-blue-400">
	{item.title}
	</a>

	<p class="truncate text-gray-600 mt-2 dark:text-gray-400">
	{item.description || 'No description available.'}
	</p>

	<div class="mt-3 flex items-center justify-between">
	<a href={`/item/${s}`} class="text-sm text-blue-700 hover:underline dark:text-blue-400">View item</a>
	<FavoritesButton
	client:only="react"
	objectID={item.objectID || item.slug || s}
	title={item.title}
	slug={s}
	thumbnail={item.thumbnail || '/default-thumbnail.jpg'}
	className="inline-flex items-center"
	/>
	</div>
	</article>
	)
	})}
	</div>
	</div>

	</section>
	</BaseLayout>